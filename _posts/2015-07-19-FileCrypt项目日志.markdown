---
layout: post
title: "FileCrypt项目开发日志" 
comments: true
share: true
tags: 笔记
---


在实验室项目基础上，进行代码整合、界面操作、流程优化。

需求：

1.	第一个进度条：跳跃性；
2.	第一个进度条：加密进度分配不合理；
3.	提示信息没有刷新；
4.	加密解密的密码输入窗口。
5.	可能存在问题：解密时候，密码可能不正确。提示信息中应该明确指出。
6.	点取消的时候，任务要终止。
1.	界面和线程处理。
2.	处理回调函数，当回调函数返回不同值的时候，加密函数底层做判断，并做相应处理，继续加解密，或终止操作。
7.	程序代码优化：有界面的代码移植到FILECRYPT里。
8.	数据共享
9.	不同平台的编译与测试
10.	在线更新
11.	文件夹支持（加解密）
12.	不要同时运行两个加解密程序。





## 解决进度： ##

6月30日 23:00 ： 
	
	把整个解决方案完全编译通过，且能够让三个dll自动注册。

**7月1日：**

预备加入输入密码的对话框，然而却发现大部分教程是针对exe的，于是开始寻找dll中加入对话框的方法，ZDB老师说以前的代码里实现过，后来在之前的代码中，发现了：

ShellExecute(0, _T("open"), m_szExecPath, szParam, _T(""), SW_SHOWNORMAL);

来调用FileCrypt项目中的exe来弹出输入框，但是不知道为什么在新的代码中老师把它去掉了。m_szFile这个变量也换作了m_vecPath这个vector容器。

我明白为什么去掉了，是为了方便调试时不用一次次输入密码。

又有新发现，本来是针对exe文件调用ShellExecute(0, _T("open"), m_szExecPath, szParam, _T(""), SW_SHOWNORMAL);，后来大概是觉得文件太多了的话传参数不方便，就重新独立于FileCrypt的exe,用了CBatchSafeManager这个类里的成员函数DoAsynBatchProc来处理加解密。

这就导致了，如果我想用原来exe里的那个输入框的话，就得改回去，所以觉得还是重新写一个比较好。

后来又听老师说了，这个CbatchSafeManager以后就是要整合到exe里去的，所以导致我其实不必写inputbox的代码了，唉，看来沟通也很重要。。

接下来处理进度条问题

Progress1上上面那个条，2是下面那个
 
注意：上面才是主进度条，下面那个是正在处理的！


**7月2日**

思路：

为了解决进度条跳跃性的问题，可采取已处理文件大小/文件大小计算的方法。

另外要注意：SetProcess(int id，int val) 的val值必须是0~100

发现一个问题，加密函数是在BasicSafe工程里的，而界面刷新是在另一个工程中，它们之间假如要共享一个数据的话要用到我不知道的知识，回去看书把。。

感觉互斥区的话，完全不知道该怎么弄了，因为FileCrypt这个项目是执行加解密的，一个块加密16字节，这个块加密执行几次的这个值我要在另一个项目的函数里得到的话，不知道该怎么传递。

现在还有个想法是弄成伪光滑前进：

思路：
	先计算所有文件大小，再计算当前加解密文件大小，它们的百分比就是x的权n%
	每开始加密一个新文件，就对上一个文件的加密进度刷新。

后来又发现在SM4fed.c中有回调函数返回加密进度的！所以不用这样做！！！

获取文件大小的时候发现，我用了fopen后即使fclose了，也不能够删除。

但是后来又奇葩的能够删除了。

之后把计算文件大小放在加解密后面，发现打开文件失败，后来才发现加解密后文件就没了！！不能计算大小。

之后又发现文件总大小到一定程度会回去，后来明白了是long长度不够，解决办法是把它们全部转换程mb，用比特单位来保存肯定不够的。

到此，把计算过程放在加解密之前，然后加解密之后放SetProcess()函数。即解决了。

但是有一个问题是无法把进度条弄满到100%，不知道为什么。

接下来处理文件夹加解密：

采取的方法，因为本来文件名是在vector<char *> pathList 里的，所以只要写个函数，能够把所有的文件名(包含文件夹名)转换为<所有文件全名>就行了，这个全名是指以当前位置起始的全名。

不要想着去底层加密函数那里去判断，底层归底层，这种东西能在外围弄就在外围弄。更何况底层还是用C的。

解决。

在代码里用 ”123” 无论是在Unicode下还是多字节下，大小都是4，因为最后会加’\0’
但是main函数入口里传入的文件名不会最后加上’\0’

**7月13日：**

调试dll时，要写上附加，因为这个是附加在explore上的！

常用方法：

1. 将DLL工程设置为启动工程
（只有这样调试器才会挂接到DLL工程上）
2.  右键单击DLL工程，选择属性（Properties)进入属性设置页面。在左边Congifure Properties下面选择Debugging
3. 在右边Debuggers to launch选择Local Windows Debugger
4. 在下面Command一览中点击右边的箭头，按浏览，之后选择会调用你代码的应用程序。
5. 在Debugger Type里面选择Mixed

（这是最重要的一步，一般来说默认的Auto。但是是Auto不出来的。如果是托管代码调用你的DLL，比如一个C#应用程序调用DLL，那么你就选Managed Only，如果是一个本地代码掉用你的DLL，比如C++应用程序，那么就选Native Only。很明显Mixed包含了这两类，选择果断选Mixed）


注意！！右键传进来的文件名也是C风格的字符串！！


**7.14**

发现文件夹加密的时候会出现访问越界，不知道什么原因

点取消仍旧无法完全删除文件

**715**

发现其实无法取消不是文件被占用的问题，而是我EndDlg后，直接会退出进程！！导致加密函数其实直接就没了，所以根本没有进行到判断callback返回值的那段！

后来我发现只要让进度条上下都是100，消息函数就会自动让他退出的！所以我在加密函数返回且确认取消了后，设置上下进度条为100

后来发现了之所以会一闪闪是因为

	//if (needUpdate)
	// InvalidateRect(hDlg, NULL, false);

这个东西存在导致了它一直会初始化窗口！


**7.17**

加解密流程

1. 从key中读取等级 0-n 的所有密钥，以及key的等级n
2. 如果是加密的话，让用户选择用哪个等级的那个密钥进行加密，并在文件中写入等级
3. 如果是解密的话，从文件中读取出加密等级，然后用那个等级的对应密钥进行解密，如果加密等级高于我的key等级，则弹出没有权限解密


我发现如果是char *类型的话，都是123456是可以正常加解密的

但是我换成是usb中的密钥后，却发现无法正常解密了！我调试的时候发现传进去的密码还是一样的，可是就是不能解密，不知道为什么

我猜测是因为最底层的那个函数的密码是char*形式的，可能是因为我传进去的是BYTE*

**7.18**

发现其实不是类型的问题，我调试的时候发现，加密的时候那个密钥很后面有一位是’\0’. 
我就意识到这个char*是要以’\0’结尾的，所以我重新写了setPwd函数，让密钥第17位是’\0’

这样总算可以了。

但是又发现解密的时候只能解密一个文件了，后来又发现传进去的密码是不对的！！！

因为我自己读出文件都是一位位读出的，所以我以为加密的密码是对的，事实上加密只用了第一位，后面的没用，因为我的字符串并不是’\0’结尾的，导致我使用strcpy()这种函数其实都失败了。我最后把所有字符串都手动在最后加了个’\0’。这才成功！

OK，接下来打扫残局，把代码优化下

解密失败的话要继续解密别的文件，不要return


**7.19**

看了设计文档后，发现我对密钥加密和口令加密的流程想法是错误的。最后改正，目前完整的方案如下：

使用流程：

1.	首先重新编译整个解决方案(若出现错误，极有可能是文件目录不一致，调整后继续重新编译)。(正常情况下编译完了后会自动regsvr32注册dll，若不行，则手动注册)
2.	进入项目输出目录(x64/x86)，打开SMFedDeamon.exe
3.	插上USBKEY，正常情况下会弹出登录框，若没有，则右下角点右键登录
4.	正确输入密码(若忘了密码，则重新用USBKEY.exe初始化，初始化密码为12345678)
5.	然后可以开始右键加解密了。
	a)	加密流程：弹出选择加密等级的对话框，口令加密以及Class0~5。若选择”口令加密” 则为输入口令加密，会弹出一个口令输入框，输入后即开始加密。选择Class0，则使用USBKEY的私钥加密(这里我认为USB私钥就是每个USB自己不一样的私钥，只有自己可以解密，不知道我的理解对不对)
	
		-1：口令加密
		0：USBKey私钥加密
		大于0：USBKey等级密钥加密
	 
	 
	b)	解密流程：

	会自动读取加密文件的加密等级，若等级为-1则弹出输入口令对话框，输入密码，若错误则发出警告并退出程序。若等级不为-1，则自动从USBKEY的所拥有的各种等级的KEY中选取相应等级KEY，进行解密。若加密文件等级超出了我USBKEY的等级，则弹出”请确认您是否拥有权限”


6.	点击取消可以终止加密，并且能够删除加密到一半的文件(删除不了的问题已经解决，不是句柄占用问题，而是点取消调用了EndDlg()导致把主进程直接给终止了，加密函数是子线程的，所以导致其实加密函数根本没有执行到remove那段)。
 



7.	当已经开启一个加密程序后，再去加密的话是不会有响应的，确保实例只运行一个







截至7-19号：

存在的问题：

1.	我现在加密一堆文件的话，如果选择了口令加密，则只要输入一次密码就能对所有文件进行加密，但是解密的话，不能够一劳永逸地输入一次密码。因为很有可能密文文件有些是key加密的，有些是口令加密的，而口令加密的也有可能不是同一个口令加密的，所以这个很复杂，且我觉得没有比较方便的解决办法，所以我现在解密许多文件的话，针对每个文件都检测加密等级，若是-1，我就会弹出一个对话框让你输入密码。

我所能够想到简化这个步骤的最好的解决办法是：

我第一次让你输入密码，第二次的时候我先用第一次输入的密码尝试看看能不能解密，假如不能，我再让你输入密码。这样一方面方便用户一次性口令解密几百个文件，在代码上也并不用增加选择框这种比较复杂的用户交互。这个可以讨论。


2．	我现在的话：

	a)	假如用户输入密码错误了一次，我就让它自动退出程序了，不进行下面的解密。
	b)	假如用户输入密码为空或者点关闭或者点取消，我都弹出”密码为空”的对话框

这是因为我那个对话框返回的参数对这些操作都是认为g_key=””，这里可以令g_key=不同值来判断，但是别的值理论都有可能是用户输入的密码啊。。这里可以比较不规范的做法是让g_key=’j9d12u98adj92’ 这种乱码的密码，再在外面判断界面上是做了什么操作。我觉得应该有更好的解决办法，但是界面的东西我并不是很懂。

3.	守护进程还有几个比较严重的问题是：

	a)	重启资源管理器后，桌面右下角托盘图标会不见了，但是后台进程还是在的。
	b)	在后台进程存在的情况下，我物理上强制拔出USBKEY，但是守护进程中原本存在的文件映射由于是强制拔出的所以还没删除。

	i.	这个问题我后来找到了case DEAMON_LOGON: 这个东西，我没非常看懂这里面的逻辑，但是我在它下面的两个条件(当前登录key被拔出和仅有一个key)下，都关闭了文件映射，这个问题是解决了，但是我不敢确保这样处理妥当，因为我没怎么看懂它的代码

	c)	我猜测真正后台运行的那个检测硬件变化的程序和桌面右下角的那个程序并不是捆绑着的，因为桌面右下角那个东西并不是很稳定，这个需要单独处理下，起码保证它和后台那个守护进程一样，长久地启动。(我猜测是重启资源管理器的时候，系统会发出销毁的信号，恰好被它接受到了，所以它会注销右下角图标，这个我还没怎么研究过)

	d)	右下角图标可以启动多个实例，这个要在main函数里加个判断。只能运行一个右下角图标。


4.	需要设置开机自动启动，但是不知道这个是代码去设置还是安装包去注册设置的

5.	USBKEY和SMFedDeamon这两个工程只能在32位下生成，64位下弄会崩溃。幸好他们的32位版本在64位下也是能够跑的

6.	我现在的代码是：假如USB没有插入，那么连口令加密也不能，其实我觉得最好就是没有USB的时候我口令也可以加密，因为USB并不是会随身带的，但是因为我现在代码结构的问题，要弄成这个功能还是有点麻烦的，所以暂时没这样弄。

7.	目前版本64位下测试有效，32位下应该不会有太大问题，因为虚拟机不支持USBKEY插入，所以暂时没测试过

8.	小于16字节文件无法加密，且会直接崩溃

--------

## 相关笔记： ##

CsafeShlExt项目的核心是CsafeShlExt这个类，对于这个类里的成员以及成员函数都要满足规范，因为是系统(explorer)去调用它的这些成员函数。


正是因为这个dll是和explorer 密切关联的，所以才会对平台要求严格，因为64位系统的explorer是64位的，所以必须采用64配置进行编译。


visualStdio工程配置中："../a/"代表a文件夹上面那层文件夹


之前不管怎么修改输出目录，dll文件都会生成到子项目目录下，而不是我整个解决方案自定义的那个输出目录，后来发现了，是在链接器的输出文件那里没有设置，把"SafeShlOverlayIcons.dll"改成："$(OutDir)SafeShlOverlayIcons.dll"，才能够让输出文件跟随输出目录变化！

文件图标覆盖的过程中之所以会发抽，是因为最早没有在注册表里没有注册".eba"的内容
后来加了条：

	CRegKey key;
	key.SetValue(HKEY_CLASSES_ROOT, _T(".eba"), _T("EBAFile"), _T(""));

才成功。


 dll注册成功后，必须重启资源管理器，不然图标覆盖功能仍然无法正常使用


与explorer相关的dll调试步骤：

	1）确保该dll没被注册
	2）关闭explorer
	3）设置需要的断点
	4）项目属性：调试：命令：C:\Windows\explorer.exe


发现SafeShlIconOverlay总是以它的当前目录为准绳，不以解决方案目录为准绳，所以我只能在生成时间里把目录写死，不然会出现.../.../Product目录在SafeShlIconOverlay的目录下了。

解决方案：后来发现是项目属性里的链接器：输出文件设置不对，要变成$(OutDir)$(TargetName)$(TargetExt)



