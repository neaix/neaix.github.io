---
layout: post
title: "C++面向对象小结" 
comments: true
share: true
tags: 
---


1. 除了赋值运算符重载函数以外，所有的运算符重载函数都可以被派生类继承。
2. 友元关系不能继承。基类的友元对派生类的成员没有特殊访问权限。
3. 重载运算符时，假如定义为成员函数，则其中已经有一个参数是this指针隐式地访问类对象的成员。若不是成员函数则要定义成友元函数。重载移动赋值运算符时，必须是成员函数。
4. 定义友元类时，仅仅只是成员对友元类开放，成员函数仍旧是隐藏的！
5. 基类里的构造函数、赋值操作符、析构函数在派生类中不能用。
6. 对于返回私有成员对象的成员函数，最好加上const，因为假如不加const，别的函数的形参是const时，就无法转变成const了
7. 容器与继承：

	如果容器类型定义为基类类型，那么虽然可以把派生类装进容器中，但是不能通过容器访问派生类自己的public成员； 	
		
	如果把容器定义为派生类类型，那么不能把基类类型装进容器中。虽然可以显式的使用强制类型转化把基类转化成派生类，放入容器，但是如果使用这些元素的派生类成员时，它们将会是未初始化的。

解决方法：

将容器类型转化成指针（最好是智能指针），

8. C++继承的权限探讨：

1.如果子类从父类继承时使用的继承限定符是public，那么

(1)父类的public成员成为子类的public成员，允许类以外的代码访问这些成员；

(2)父类的private成员仍旧是父类的private成员，#子类成员不可以访问这些成员#；

(3)父类的protected成员成为子类的protected成员，只允许子类成员访问；

**注意：父类的构造函数是不能继承的**

这时要用子类的构造函数去调用父类的构造函数：

	Student(const string name) :Person(name){}




2.如果子类从父类继承时使用的继承限定符是private，那么

(1)父类的public成员成为子类的private成员，只允许子类成员访问；

(2)父类的private成员仍旧是父类的private成员，子类成员不可以访问这些成员；

(3)父类的protected成员成为子类的private成员，只允许子类成员访问；





3.如果子类从父类继承时使用的继承限定符是protected，那么

(1)父类的public成员成为子类的protected成员，只允许子类成员访问；

(2)父类的private成员仍旧是父类的private成员，子类成员不可以访问这些成员；

(3)父类的public成员成为子类的protected成员，只允许子类成员访问；