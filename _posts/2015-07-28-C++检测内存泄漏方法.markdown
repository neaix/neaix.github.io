---
layout: post
title: "C++检测内存泄漏方法" 
comments: true
share: true
tags: 笔记
---


把下面的宏放在自定义的CheckMemoryLeak.h文件中

	#pragma once
	#ifdef _DEBUG
	#define DEBUG_CLIENTBLOCK   new( _CLIENT_BLOCK, __FILE__, __LINE__)
	#else
	#define DEBUG_CLIENTBLOCK
	#endif
	#define _CRTDBG_MAP_ALLOC
	#include <stdlib.h>
	#include <crtdbg.h>
	#ifdef _DEBUG
	#define new DEBUG_CLIENTBLOCK
	#endif



然后每次new,都会转向宏定义,在按F5 DEBUG的时候,注意输出栏那里会提示:

	Detected memory leaks!
	Dumping objects ->
	d:\项目\visual c++ 项目\win32test\win32test\win32test.cpp(24) : {67} client block at 0x00765AF8, subtype 0, 4 bytes long.
	 Data: <    > 0A 00 00 00 
	Object dump complete.

会主动显示出内存泄漏代码的位置!!!

可以考虑把上述代码给包含到stdafx.h中去.

上述代码缺点是不支持malloc,所以以后要坚持使用new来进行内存管理.

----

**new 和 malloc 的区别:**

1. new 是c++中的操作符，malloc是c 中的一个函数

2. new 不止是分配内存，而且会调用类的构造函数，同理delete会调用类的析构函数，而malloc则只分配内存，不会进行初始化类成员的工作，同样free也不会调用析构函数

3. 内存泄漏对于malloc或者new都可以检查出来的，区别在于new可以指明是那个文件的那一行，而malloc没有这些信息。

4. new可以看成两个动作：
	1. 分配内存（相当于malloc)
	2. 引发构造函数。
	
5. new 是个操作符,和什么"+","-","="...有一样的地位.malloc是个分配内存的函数,供你调用的.   

6. new是保留字,不需要头文件支持.   malloc需要头文件库函数支持.   

7. new   建立的是一个对象,  malloc分配的是一块内存.  

8. new建立的对象你可以把它当成一个普通的对象,用成员函数访问,不要直接访问它的地址空间 . malloc分配的是一块内存区域,就用指针访问好了,而且还可以在里面移动指针.  

9. new 和 malloc效率比较:
	1. new 有三个字母, malloc有六个字母
	2. new可以认为是malloc加构造函数的执行。
	3. new出来的指针是直接带类型信息的。而malloc返回的都是void指针。

10. malloc与free是C++/C语言的标准库函数，new/delete是C++的运算符。它们都可用于申请动态内存和释放内存。

11. 对于非内部数据类型的对象而言，光用maloc/free无法满足动态对象的要求。对象在创建的同时要自动执行构造函数，对象在消亡之前要自动执行析构函数。由于malloc/free是库函数而不是运算符，不在编译器控制权限之内，不能够把执行构造函数和析构函数的任务强加于malloc/free。因此C++语言需要一个能完成动态内存分配和初始化工作的运算符new，以及一个能完成清理与释放内存工作的运算符delete。注意new/delete不是库函数。


malloc/free和new/delete如何实现对象的动态内存管理，见示例。

	
	class Obj
	{
	public:
		Obj() { cout << “Initialization” << endl; }
		~Obj() { cout << “Destroy” << endl; }
		void Initialize() { cout << “Initialization” << endl; }
		void Destroy() { cout << “Destroy” << endl; }
	
	};
	
	
	void UseMallocFree()
	{
		Obj *a = (obj *)malloc(sizeof(obj));     // 申请动态内存
		a->Initialize();                          // 初始化
		a->Destroy();     // 清除工作
		free(a);          // 释放内存
	}
	
	
	void UseNewDelete()
	{
		Obj    *a = new Obj;    // 申请动态内存并且初始化
		delete a;             // 清除并且释放内存
	}


类Obj的函数Initialize模拟了构造函数的功能，函数Destroy模拟了析构函数的功能。函数UseMallocFree中，由于malloc/free不能执行构造函数与析构函数，必须调用成员函数Initialize和Destroy来完成初始化与清除工作。函数UseNewDelete则简单得多。

所以我们不要企图用malloc/free来完成动态对象的内存管理，应该用new/delete。由于内部数据类型的“对象”没有构造与析构的过程，对它们而言malloc/free和new/delete是等价的。

既然new/delete的功能完全覆盖了malloc/free，为什么C++不把malloc/free淘汰出局呢？这是因为C++程序经常要调用C函数，而C程序只能用malloc/free管理动态内存。

如果用free释放“new创建的动态对象”，那么该对象因无法执行析构函数而可能导致程序出错。如果用delete释放“malloc申请的动态内存”，理论上讲程序不会出错，但是该程序的可读性很差。所以new/delete必须配对使用，malloc/free也一样。

new delete在实现上其实调用了malloc,free函数。


------

另外,还有个差不多的方法是:

crtdbg.h 文件里有一个:_CrtDumpMemoryLeaks() 函数,这个函数的作用是如果找到記憶體遺漏，則 _CrtDumpMemoryLeaks 傳回TRUE。 否則，函式會傳回 false。

	int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance,
		PSTR szCmdLine, int iCmdShow)
	{
		//Codes
		_CrtDumpMemoryLeaks();
		return 0;
	}

如果存在内存泄漏,_CrtDumpMemoryLeaks()会返回true,否则false,按F5调试可以在输出里看到,只不过无法看到错误的何处罢了.


----

现在出了智能指针,最好还是去用智能指针!

----------

####  参考资料：  ####


- [https://msdn.microsoft.com/zh-tw/library/d41t22sb.aspx](https://msdn.microsoft.com/zh-tw/library/d41t22sb.aspx)
- [http://www.cppblog.com/vczh/archive/2010/06/22/118493.html](http://www.cppblog.com/vczh/archive/2010/06/22/118493.html)
