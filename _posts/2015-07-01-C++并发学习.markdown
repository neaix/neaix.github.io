---
layout: post
title: "C++并发学习" 
comments: true
share: true
tags: 笔记
---

并发是指两个或更多独立的活动同时发生。

以前，大多数计算机都有一个处理器，具有单个处理单元（processing unit）或核心（core）。这种机器只能在某一时刻执行一个任务，但它可以每秒进行多次任务切换。通过“这个任务做一做一会，再切换到别
的任务，再做一会儿”的方式，让任务执行“看起来”是并行的。这种方式我们称为“任务切换（task switching）”。如今，我们
仍然将这样的系统论为并发（concurrency）：因为任务切换得太快，以至于无法分辨任务在何时会被暂时挂起，而切换到另
一个任务。任务切换会给用户和应序本身造成一种“并发的假象”。

无论它们拥有多个处理器或一个多核处理器（再或两者兼具），这些计算机能够真正的并行多个任务。我们称其为“硬件并发
（hardware concurrency）”。

在单核机器上做任务切换时，每个任务的块交织进行。但它们中间有一小段分隔；为了实现交织进行，系统每次从一个任务切换到另一个时都需要切换一次上下文（context switch），这是需要时间的。为了进行上下文切换，操作系统必须得为当前运行的任务保
存CPU的状态和指令指针，算出要切换到哪个任务，并为即将切换到的任务重新加载处理器状态。然后，CPU可能要将新任
务的指令和数据的内存载入到缓存中，这可能阻止CPU执行任何指令，从而造成的更多的延迟。


-----

####  多进程并发  ####

使用并发的第一种方法，是将应用程序分为多个独立的、单线程的进程，它们在同一时刻运行。这些独立的进程可以通过进程间常规的通信渠道互相传递讯息（信号、套接字、文件、管
道等等）。不过，这种进程之间的通信通常设置复杂，或是速度慢，或两者兼备，这是因为操作系统会在进程间提供了一定
量的保护措施，以避免一个进程去修改另一个进程的数据。还一个缺点是，运行多个进程所需的固定开销：需要时间启动进
程，操作系统必须投入内部资源来管理进程，等等。

####  多线程并发  ####

线程很像轻量级的进程：每个线程相互独立运行，且线程可以在不同的指
令序列中运行。但时，进程中的所有线程都共享相同的地址空间，并且从所有线程中访问到大部分数据———全局变量仍然
是全局的，指针、对象的引用或数据可以在线程之间传递。虽然，进程之间通常共享内存，但这种共享通常也是难以建立，
并且难以管理的。因为，同一数据的内存地址在不同的进程中是不相同。

地址空间共享，以及缺少线程间数据的保护，使得操作系统的记录工作量减小，所以使用多线程相关的开销远远小于使用多
个进程。不过，共享内存的灵活性是有代价的：如果数据要被多个线程访问，那么程序员必须确保当每个线程访问时所访问
到的数据是一致的。

------

####  什么时候不使用并发：  ####

基本上，不使用并发的唯一原因就是，收益比不上成本。使用并发的代码
在很多情况下难以理解，因此编写和维护的多线程代码就会产生直接的脑力成本，同时额外的复杂性也可能引起更多的错误（bugs）。除非潜在的性能增益足够大或关注点分离地足够清晰，能抵消所需的额外的开发时间以及与维护多线程代码相关
的额外成本（代码正确的前提下）；否则，别用并发。

因为操作系统需要分配内核相关资源和堆栈空间，所以在启动线程时存在固有的开销，
然后才能把新线程加入调度器中，所有这一切都需要时间。如果在线程上的任务完成得很快，那么任务实际执行的时间要比启动线程的时间小很多，这就会导致应用程序的整体性能还不如直接使用“产生线程”的方式。

此外，线程是有限的资源。如果让太多的线程同时运行，则会消耗很多操作系统资源，从而使得操作系统整体上运行得更加缓慢。不仅如此，因为每个线程都需要一个独立的堆栈空间，所以运行太多的线程也会耗尽进程的可用内存或地址空间。对于一个可用地址空间为4GB（32bit）的平坦架构的进程来说，这的确是个问题：如果每个线程都有一个1MB的堆栈（很多系统都会这样分配），那么4096个线程将会用尽所有地址空间，不会给代码、静态数据或者堆数据留有任何空间。即便64位
（或者更大）的系统不存在这种直接的地址空间限制，但其他资源有限：如果你运行了太多的线程，最终也是出会问题的。

尽管线程池可以用来限制线程的数量，但这并不是灵丹妙药，它也有自己的问题。

当客户端/服务器（C/S）应用在服务器端为每一个链接启动一个独立的线程，对于少量的链接是可以正常工作的，但当同样的技术用于需要处理大量链接的高需求服务器时，也会因为线程太多而耗尽系统资源。在这种场景下，谨慎地使用线程池可以对信能产生优化（参见第9章）。

最后，运行越多的线程，操作系统就需要做越多的上下文切换。每个上下文切换都需要耗费本可以花在有价值工作上的时间。

-------

使用线程的样例：

	#include <iostream>
	#include <thread>
	
	//每个线程都必须具有一个初始函数（initial function）
	//对于应用程序来说，初始线程是main()，但是对于所有其他线程，
	//都在 std::thread 对象的构造函数中指定
	
	void hello(){
		std::cout << "Hello" << std::endl;
	}
	int main(){
		std::thread t(hello);
	
	/*join()会导致调用线程（即main()函数的线程）等待与 std::thread 对象相关联的线程。
	如果它不等待新线程结束，它就将自顾自地继续运行到main()的结束，
	从而结束程序------有可能发生在新线程有机会运行之前。
	*/
		t.join();//加入式，即等待这个线程执行完毕
		//t.detach();//分离式，即不等待

	
		//在新的线程启动之后，初始线程继续执行
		std::cout << "main" << std::endl;
	}


-------


## 线程管理 ##

####  启动线程  ####

线程在一个 std::thread 对象创建（为线程指定任务）时启动。 在最简单的情况下，通常是无参数无返回（void-returning）的函数。这种函数在其所属线程上运行，直到函数执行完毕，线程也就结束了。在一些极端情况下，在线程运行时，任务中的函数对象需要通过某种通讯机制进行参数的传递，或者执行一系列独立操作；线程的停止，也是通过通讯机制传递信号进行控制的。使用C++线程库启动线程，通常可以归结为构造 std::thread 对象：

	
	void do_some_work();
	std::thread my_thread(do_some_work);


如同大多数C++标准库一样， std::thread 可用于可调用（callable）类型，你可以将带有函数调用符类型的实例传入 std::thread 类中，替换默认的构造函数。

	class background_task
	{
	public:
	void operator()() const
	{
	do_something();
	do_something_else();
	}
	};
	background_task f;
	std::thread my_thread(f);
	//即用类的构造函数方式来调用多个不同类别的函数，使其更清晰！


这里是你不能够这样：

	
	std::thread my_thread(background_task());

这里相当与声明了一个名为my_thread，带有一个参数（是一个函数指针，指向一个没有参数并返回background_task对象
的函数），并且返回一个 std::thread 对象的函数，而非启动了一个线程。 

你可以使用在前面命名函数对象的方式，或使用多组括号①，再或使用新统一的初始化语法，来避免这个问题:

	std::thread my_thread((background_task())); // 1
	std::thread my_thread{background_task()}; // 2

当你启动了线程，你需要明确一下自己的决定，是要等待线程结束（加入式），还是让其自主运行（分离式）。

如果你 在 std::thread 对象销毁之前没有做出决定，那么你的程序就会终止（ std::thread 的析构函数会调用 std::terminate() ）。因此，即便是有异常的存在，你也需要确保线程能够正确的加入（joined）或分离（detached）。

调用join()的行为，还清理了线程相关的存储部分，这样 std::thread 对象将不再与已经完成的线程有任何关联。这就意味着，你只能对一个线程使用一次join();一旦已经使用过join()， std::thread 对象就不能再次加入了，当对其使用joinable()时，将返回否（false）。

对一个 std::thread 对象使用detach()就会将这个线程搁置在后台运行，这就意味着不能与这个线程产生直接交互。

通常，称分离线程为守护线程（daemon threads）。在UNIX中守护线程是指，运行在后台，且没有任何可用用户接口的线程。这种线程的特点就是长时间运行；它们的生命周期可能会从某一个应用起始到结束，也会在后台执行诸如监事文件系统的任务，还有可能对未使用的缓存进行清理，亦或对数据结构进行优化。另一方面，它也使用分离线程的另一种机制，确定线程什么时候结束，或者在“发后即忘”（fire and forget）的任务在哪里使用
到了这个线程。 你可以调用 std::thread 的成员函数detach()来分离一个线程。在这之后，对应的 std::thread 对象就与这个实际执行的线程无关了，并且这个线程也无法再加入了。

当一个 std::thread 对象使用t.joinable()返回的是true，那就可以对其使用t.detach()。


(中间有一大截暂时跳过)

----------

## 使用互斥量保护共享数据 ##


当访问共享数据前，使用互斥量将相关数据锁住，再当访问结束后，将数据解锁。线程库需要保证，当一个线程使用一个特
定互斥量锁住共享数据时，其他的线程想要访问锁住的数据，都必须等到之前那个线程对数据进行解锁后，才能再进行访
问。这就保证了所有线程只能看到自治区域内的共享数据，并避免不变量破坏。

在C++中，可以使用 srd::mutex 来创建一个互斥量实例，通过调用成员函数lock()进行上锁；同样的，也可以调用成员函数unlock()进行解锁。不过，这里不推荐实践中直接去调用成员函数，因为调用成员函数就意味着，你必须记住在每个函数出口都要去调用unlock()，也包括异常的情况。

C++标准库提供 std::lack_guard 类模板，实现RAII风格的互斥量；其会在构造的
时候，提供已锁的互斥量，并在析构的时候进行解锁，这就保证了一个已锁的互斥量可以被正确的解锁。下面展示了如何在多线程程序中，使用 std::mutex 构造std::lock_guard 实例，对一个列表进行访问保护。 std::mutex 和 std::lock_guard 都在头文件中声明。

	#include <list>
	#include <mutex>
	#include <algorithm>
	
	std::list<int> some_list; // 全局变量
	std::mutex some_mutex; // 全局互斥量保护上面的全局变量
	
	void add_to_list(int new_value)
	{
	
		std::lock_guard<std::mutex> guard(some_mutex); // 3
	
	
		some_list.push_back(new_value);
	}
	
	bool list_contains(int value_to_find)
	{
		std::lock_guard<std::mutex> guard(some_mutex); // 4
		return std::find(some_list.begin(), some_list.end(), value_to_find) != some_list.end();
	}
	
	/*
	3,4是用std::lock_guard实现的互斥，使得list_contains()不可能看到
	被add_to_list()修改到一半的列表。
	
	上面的方法用来全局的互斥量和两个函数，实际应用中，应该把
	需要保护的数据通常会与互斥量放在同一个类中，而不是定义成全局变量。
	
	在这种情况下，函数add_to_list和list_contains可以作为这个类的成员函数
	，并且互斥量和要保护的数据，在类中都需要定义为private成员，这就会让访问
	数据的代码变的清晰，并且容易看出在什么时候对互斥量上锁。当所有成员函数都
	会在调用时对数据上锁，在结束的时候对数据解锁，那么这就保证了数据访问时不
	变量不被破坏。
	*/





----------

####  参考资料：  ####


- [C++并发编程中文版](http://chenxiaowei.gitbooks.io/cpp_concurrency_in_action/content/content/)
