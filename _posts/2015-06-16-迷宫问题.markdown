---
layout: post
title: "迷宫问题的解法" 
comments: true
share: true
tags: 笔记
---


	
	//总结：
	//1.对于广搜深搜缺乏基本认识
	//2.数组其实设成全局就行了，不要用函数去传参来调用（假如用递归的话）
	//3.下面代码是利用栈的先入先出做的，是深搜。若利用队列的先入后出的话，是广搜
	//4.深搜无法得到最短路，广搜可以得到最短路
	//5.我的深搜版本的基本思路是：
	//	1)先弄一个栈用来存放路径。起始只包含起点
	//	2)后加入循环，在各个方向依次尝试，若前进到一定程度堵塞了，则原路返回(pop())
	//	3)最后若得到空的栈，说明已经退无可退了，迷宫无解。
	
	
	#include <stack>
	#include <iostream>
	#include <ctime>
	
	
	#define MAX 20
	using namespace std;
	
	
	
	class point
	{
	public:
		point(){ x = 0, y = 0; }
		point(int _x, int _y) :x(_x), y(_y){}
		int x;
		int y;
	};
	
	
	
	/* 随机生成迷宫数据 */
	void makeMaze(int maze[][MAX]){
		srand((unsigned)time(NULL));
		for (int i = 0; i < MAX; ++i){
			for (int j = 0; j < MAX; ++j){
				if (i == MAX - 1 || i == 0 || j == MAX - 1 || j == 0)
					maze[i][j] = 1;//1代表是堵住的，这里把边界都设成1
				else{
					maze[i][j] = rand() % 2;
				}
				cout << maze[i][j] << " ";
			}
			cout << endl;
		}
	}
	
	
	
	//bool bfs(int maze[][MAX], const point &p1, const point &p2, stack<point> &stk){
	//
	//}
	
	
	
	int main(){
		while (true)
		{
			int maze[MAX][MAX];
			makeMaze(maze);//迷宫不一定有解
	
			point p1, p2;
			stack<point> stk;
			cout << "输入起点坐标和终点坐标：" << endl;
			cin >> p1.x >> p1.y >> p2.x >> p2.y;
	
			stk.push(p1);
			while (!(stk.empty()))
			{
				maze[stk.top().x][stk.top().y] = 1;
				//由于自己走过的路都不能走，而墙也是类似作用，故两者可都设为1
				if ((stk.top().x == p2.x) && (stk.top().y == p2.y))
					break;
	
				if (maze[stk.top().x][stk.top().y + 1] == 0){
					stk.push(point(stk.top().x, stk.top().y + 1));
				}
				else if (maze[stk.top().x][stk.top().y - 1] == 0){
					stk.push(point(stk.top().x, stk.top().y - 1));
				}
				else if (maze[stk.top().x + 1][stk.top().y] == 0){
					stk.push(point(stk.top().x + 1, stk.top().y));
				}
				else if (maze[stk.top().x + 1][stk.top().y - 1] == 0){
					stk.push(point(stk.top().x + 1, stk.top().y - 1));
				}
				else if (maze[stk.top().x + 1][stk.top().y + 1] == 0){
					stk.push(point(stk.top().x + 1, stk.top().y + 1));
				}
				else if (maze[stk.top().x - 1][stk.top().y] == 0){
					stk.push(point(stk.top().x - 1, stk.top().y));
				}
				else if (maze[stk.top().x - 1][stk.top().y + 1] == 0){
					stk.push(point(stk.top().x - 1, stk.top().y + 1));
				}
				else if (maze[stk.top().x - 1][stk.top().y - 1] == 0){
					stk.push(point(stk.top().x - 1, stk.top().y - 1));
				}
				else
					stk.pop();
			}
	
			//下面用于可视化输出结果
			if (stk.empty())
				cout << "迷宫无解！" << endl;
			else{
				int cnt = 10;
				while (stk.size() != 0){
					maze[stk.top().x][stk.top().y] = cnt++;//用数字标出路径
					stk.pop();
				}
				for (int i = 0; i < MAX; ++i){
					for (int j = 0; j < MAX; ++j){
						cout << maze[i][j] << " ";
					}
					cout << endl;
				}
			}
			cout << "\n-------------------\n" << endl;
		}
	
	}
	
	
