---
layout: post
title: "WIN32API操作注册表笔记（附开机自启动）"
comments: true
share: true
tags: 笔记
---


完全基于API操作，我封装成函数了，并且设置了一个结构体：RegInfo，注册表的基本信息都可以填入RegInfo中。当然这种"封装"很低等，且不安全。我只是为了方便才弄的，直接操作API其实也很简单。

网上很多例子全是用MFC搞，以我目前的浅显认知，说实话还真没看出MFC好在哪里，API其实是很干净的，以后用C/C++做界面时，能用API就用API 。要么就别用C++写界面了。。。

项目放在了github上：[https://github.com/joway/NotesCodesInLearning/tree/master/ReadWriteRegister](https://github.com/joway/NotesCodesInLearning/tree/master/ReadWriteRegister)

---
ReadWriteRegister.h


	#pragma once
	
	class RegInfo
	{
	public:
		HKEY HKey;//根数名字（值为HKEY_LOCAL_MACHINE等宏）eg:HKEY_LOCAL_MACHINE
		LPCWSTR SubKey;//子键 eg："*\\shell\\Joway"
		LPCWSTR ValueName;//值名 eg:Wong
	
		LPDWORD ValueType;
		//值类型 eg:REG_SZ(固定长度的文本字符串。)
	
		WCHAR ValueData[MAX_PATH];//值数据（ValueData的缓冲区） 
	    //eg:{09a28848-0e97-4cef-b950-cea037161155}
		DWORD  DataLen = 256; //装载ValueData的缓冲区"长度"的一个变量
	
		RegInfo() {
			ValueType = (LPDWORD)REG_NONE;//若不指定初始值则其会没有大小！
			DataLen = 256;
		}
	
		//一析构了以后反而会出现堆错误！	但是这里的确存在内存泄漏问题
		//后来把动态分配的内存全部换成数组以后才正常！
		//~RegInfo() {
		//	free(ValueData);
		//	free(ValueType);
		//}
	};
	
	
	
	//GetRegister()需要构造的RegInfo必须指定了hKey,subKey,ValueName
	//调用后填上ValueType、ValueData、DataLen
	//返回TRUE表示成功！
	/*
	调用方法：
	RegInfo ri;
	ri.HKey = HKEY_CLASSES_ROOT;
	ri.SubKey = L"*\\shell\\Joway";
	ri.ValueName = NULL;
	ri.ValueType = (LPDWORD)REG_SZ;
	WCHAR* val;
	wcscpy(ri.ValueData, L"1234567890");
	ri.DataLen = ((wcslen(ri.ValueData) + 1)*sizeof(WCHAR));
	if (SetRegister(ri))
	MessageBox(NULL,L"Success!", L"", MB_OK);
	else
	MessageBox(NULL,L"Fail!", L"", MB_OK);
	*/
	BOOL GetRegister(RegInfo &regInfo);
	
	
	
	//SetRegister()需要构造的RegInfo必须全部指定hKey,subKey,ValueName,ValueType,ValueData,DataLen
	//ValueName为NULL则写入默认值
	//返回TRUE表示成功！
	/*
	调用方法：
	RegInfo ri;
	ri.HKey = HKEY_CLASSES_ROOT;
	ri.SubKey = L"*\\shell\\Joway";
	ri.ValueName = NULL;
	if (GetRegister(ri)) {
	MessageBox(NULL,(ri.ValueData), L"", MB_OK);
	}
	else
	MessageBox(NULL,L"Fail!", L"", MB_OK);
	*/
	BOOL SetRegister(const RegInfo &regInfo);
	
	
	
	//删除注册表子键的值
	//要构造出hKey,subKey,ValueName
	/*
	调用方法：
	RegInfo ri;
	ri.HKey = HKEY_CLASSES_ROOT;
	ri.SubKey = L"*\\shell\\Joway";
	ri.ValueName = NULL;
	if (DelRegisterValue(ri))
	MessageBox(NULL, L"Success!", L"", MB_OK);
	else
	MessageBox(NULL, L"Fail!", L"", MB_OK);
	*/
	BOOL DelRegisterValue(const RegInfo &regInfo);
	
	
	
	//删除注册表子键
	//要构造出hKey,subKey
	//删除subKey路径内最后一个子键！
	/*
	调用方法：
	RegInfo ri;
	ri.HKey = HKEY_CLASSES_ROOT;
	ri.SubKey = L"*\\shell\\Joway";
	if (DelRegisterKey(ri))
	MessageBox(NULL, L"Success!", L"", MB_OK);
	else
	MessageBox(NULL, L"Fail!", L"", MB_OK);
	*/
	BOOL DelRegisterKey(const RegInfo &regInfo);
	
	
	
	//设置开机自动启动
	/*调用方法：
	SetAutoRun(L"\"D:\\项目\\Visual C++ 项目\\项目--密码文件加密\\项目--密码文件加密\\Product\\x64\\SMFedDeamon.exe\"")
	*/
	BOOL SetAutoRun(const WCHAR* exePath);
	
	
	
	////列举某个注册表项之下的所有子项实例(有点复杂，暂时不考虑)
	//BOOL GetRegisterQueryKey(const RegInfo &regInfo);



---

ReadWriteRegister.cpp

	#include "stdafx.h"
	#include "ReadWriteRegister.h"
	
	
	
	BOOL GetRegister(RegInfo &regInfo)
	{
		HKEY  hkey;
		LONG nFlag;//是否成功
	
		nFlag = RegOpenKeyEx(    //打开一个指定的注册表键
			regInfo.HKey,   //需要打开的主键（根项）的名称
			regInfo.SubKey, //需要打开的子键的名称
			NULL, // 保留值，设为0
			KEY_READ,// 安全访问标记，也就是权限 
			&hkey);// 得到的将要打开键的句柄
				   // 如果函数调用成功，则返回0（ERROR_SUCCESS）。
				   //否则，返回值为文件WINERROR.h中定义的一个非零的错误代码。
	
		if (nFlag == ERROR_SUCCESS)
		{
			//RegQueryValueEx检索一个已打开的注册表句柄中指定的注册表键的类型和设置值。
			//返回值零（ERROR_SUCCESS）表示成功。其他任何值都代表一个错误代码
			if (RegQueryValueEx(hkey, //一个已打开项的句柄
				regInfo.ValueName, //要获取值的名字，注册表键的名字
				NULL, //保留项，无用，设为零
				regInfo.ValueType, ////用于装载取回"类型"的一个变量
				(LPBYTE)regInfo.ValueData, //用于装载指定"数值"的一个缓冲区
				&regInfo.DataLen) //用于装载lpData缓冲区"长度"的一个变量。 
								  //一旦返回，它会设为实际装载到缓冲区的字节数
				== ERROR_SUCCESS)
				RegCloseKey(hkey);
			else
				return FALSE;
		}
		else
			return FALSE;
		return TRUE;
	}
	
	
	BOOL SetRegister(const RegInfo &regInfo)
	{
		HKEY  hkey;
	
		if (RegCreateKey(regInfo.HKey, regInfo.SubKey, &hkey)) {
			RegCloseKey(hkey);
			return FALSE;
		}
	
		//若想要设置的注册表项下不是默认值，即有名称值的数据和类型时，
		//可以调用RegSetValueEx函数，该函数将在注册表项下设置指定值的数据和类型。
		//返回值 0（ERROR_SUCCESS）表示成功
		if (RegSetValueEx(hkey,      //  subkey  handle
			regInfo.ValueName,          //  为NULL则写入默认值
			0,                     //  must  be  zero
			(DWORD)regInfo.ValueType, //  value  type
			(LPBYTE)regInfo.ValueData,       // 指向一个缓冲区，该缓冲区包含了欲为指定值名称存储的数据。
			regInfo.DataLen) != ERROR_SUCCESS)  //指定由lpData参数所指向的数据的大小，单位是字节。
		{
			RegCloseKey(hkey);
			return FALSE;
		}
	
		RegCloseKey(hkey);
		return TRUE;
	}
	
	
	BOOL DelRegisterValue(const RegInfo &regInfo) {
		HKEY hKey;
		//打开注册表
		if (RegOpenKeyEx(
			regInfo.HKey,
			regInfo.SubKey,
			NULL,              // 保留参数NULL
			KEY_WRITE,      // 打开权限，写入
			&hKey           // 打开之后的句柄
			) != ERROR_SUCCESS) {
			RegCloseKey(hKey);
			return FALSE;
		}
		// 删除 regInfo.HKey\regInfo.SubKey 里的ValueName
		if (RegDeleteValue(hKey, regInfo.ValueName) != ERROR_SUCCESS) {
			RegCloseKey(hKey);
			return FALSE;
		}
		else
		{
			//关闭注册表:
			RegCloseKey(hKey);
			return TRUE;
		}
	
	}
	
	
	BOOL DelRegisterKey(const RegInfo &regInfo) {
		HKEY hKey;
		//打开注册表
		// 删除 regInfo.SubKey里最后那个子键
		WCHAR finalKey[MAX_PATH];
		WCHAR lastKey[MAX_PATH];
		wcscpy(finalKey, regInfo.SubKey);
		wcscpy(lastKey, regInfo.SubKey);
		while ((wcsstr(finalKey, L"\\")) != NULL) {
			wcscpy(finalKey, wcsstr(finalKey, L"\\") + 1);
		}
		lastKey[wcsstr(lastKey,finalKey) - lastKey] = L'\0';
		if (RegOpenKeyEx(
			regInfo.HKey,
			lastKey,//到要删除键之前的路径！
			NULL,              // 保留参数NULL
			KEY_WRITE,      // 打开权限，写入
			&hKey           // 打开之后的句柄
			) != ERROR_SUCCESS) {
			RegCloseKey(hKey);
			return FALSE;
		}
	
		if (RegDeleteKey(hKey, finalKey) != ERROR_SUCCESS) {
			RegCloseKey(hKey);
			return FALSE;
		}
		else
		{
			//关闭注册表:
			RegCloseKey(hKey);
			return TRUE;
		}
	
	}
	
	BOOL SetAutoRun(const WCHAR* exePath) {
		HKEY hKey;
		//打开注册表
		if (RegOpenKeyEx(
			HKEY_LOCAL_MACHINE, // 本机注册表（要打开的注册表）
			L"Software\\Microsoft\\Windows\\CurrentVersion\\Run", // 要打开的注册表项名称
			0,              // 保留参数必须填 0
			KEY_SET_VALUE,  // 打开权限，写入
			&hKey           // 打开之后的句柄
			) != ERROR_SUCCESS) {
			RegCloseKey(hKey);
			return FALSE;
		}
		//接下来根据exe路径得到exe的名字作为键名
		WCHAR keyName[MAX_PATH];
		wcscpy(keyName, exePath);
		while ((wcsstr(keyName, L"\\")) != NULL) {
			wcscpy(keyName, wcsstr(keyName, L"\\") + 1);
		}
		auto temp = wcsstr(keyName, L".exe");
		if (temp != NULL) {
			keyName[temp - keyName] = L'\0';
		}
		// 在注册表中设置(没有则会新增一个值)
		if (RegSetValueEx(
			hKey,
			keyName, // 键名
			0,                  // 保留参数必须填 0
			REG_SZ,             // 键值类型为字符串
			(LPBYTE)exePath, // 字符串首地址
			wcslen(exePath)*sizeof(WCHAR)        // 字符串长度
			) != ERROR_SUCCESS) {
			RegCloseKey(hKey);
			return FALSE;
		}
	
		//关闭注册表:
		RegCloseKey(hKey);
		return TRUE;
	}
	



---
####  参考资料：  ####
- http://www.lellansin.com/windows-api-%E6%95%99%E7%A8%8B%EF%BC%88%E5%8D%81%EF%BC%89-%E6%B3%A8%E5%86%8C%E8%A1%A8%E6%93%8D%E4%BD%9C.html
